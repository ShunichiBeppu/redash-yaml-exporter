## Chrome拡張機能 技術仕様書

### プロジェクト構成
```
redash-yaml-exporter/
├── manifest.json
├── src/
│   ├── content/
│   │   └── dashboard.ts
│   ├── background/
│   │   └── background.ts
│   ├── utils/
│   │   ├── api.ts
│   │   ├── yaml-converter.ts
│   │   ├── dom-utils.ts
│   │   └── types.ts
│   └── styles/
│       └── content.css
├── dist/ (ビルド出力)
├── webpack.config.js
├── tsconfig.json
├── package.json
└── .gitignore
```

### 1. manifest.json (Manifest V3)
```json
{
  "manifest_version": 3,
  "name": "Redash YAML Exporter",
  "version": "1.0.0",
  "description": "Export Redash dashboard queries to YAML format",
  "permissions": [
    "storage"
  ],
  "host_permissions": [
    "http://localhost:*/dashboards/*",
    "https://*.redash.io/dashboards/*"
  ],
  "content_scripts": [
    {
      "matches": [
        "http://localhost:*/dashboards/*",
        "https://*.redash.io/dashboards/*"
      ],
      "js": ["dist/content/dashboard.js"],
      "css": ["src/styles/content.css"],
      "run_at": "document_end"
    }
  ],
  "background": {
    "service_worker": "dist/background/background.js"
  },
  "web_accessible_resources": [
    {
      "resources": ["src/styles/content.css"],
      "matches": ["<all_urls>"]
    }
  ]
}
```

### 2. TypeScript型定義 (src/utils/types.ts)
```typescript
export interface RedashQuery {
  id: number;
  name: string;
  description: string | null;
  query: string;
  created_at: string;
  updated_at: string;
  api_key?: string;
  data_source_id: number;
}

export interface RedashVisualization {
  id: number;
  name: string;
  query: RedashQuery;
  type: string;
  options: Record<string, any>;
}

export interface RedashWidget {
  id: number;
  width: number;
  height: number;
  options: Record<string, any>;
  visualization?: RedashVisualization;
  text?: string;
}

export interface RedashDashboard {
  id: number;
  name: string;
  slug: string;
  user_id: number;
  layout: string;
  dashboard_filters_enabled: boolean;
  widgets: RedashWidget[];
  tags: string[];
  created_at: string;
  updated_at: string;
}

export interface YamlPage {
  _id: string;
  kind: string;
  name: string;
  body: {
    type: string;
    content: Array<{
      type: string;
      attrs?: Record<string, any>;
      content?: Array<{
        type: string;
        text?: string;
        attrs?: Record<string, any>;
        content?: any[];
      }>;
    }>;
  };
  order: number;
  width: {
    fixed_width: number;
    width_type: string;
    max_width: number;
  };
  notebook_param_widget_values: any[];
  page_param_widgets: any[];
  page_param_widget_values: any[];
}

export interface YamlOutput {
  _id: string;
  schema_version: string;
  icon: null;
  name: string;
  palette_key: string;
  pages: YamlPage[];
  notebook_param_widgets: any[];
}

export interface ExportMessage {
  action: 'exportDashboard';
  dashboardData: RedashDashboard;
}

export interface ExportResponse {
  success: boolean;
  data?: string;
  error?: string;
}
```

### 3. DOM操作ユーティリティ (src/utils/dom-utils.ts)
```typescript
export class DOMObserver {
  private observer: MutationObserver | null = null;
  private callbacks: Set<() => void> = new Set();

  start(): void {
    if (this.observer) return;

    this.observer = new MutationObserver(() => {
      this.callbacks.forEach(callback => callback());
    });

    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: false
    });
  }

  stop(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }

  addCallback(callback: () => void): void {
    this.callbacks.add(callback);
  }

  removeCallback(callback: () => void): void {
    this.callbacks.delete(callback);
  }
}

export function waitForElement(
  selector: string, 
  timeout: number = 10000
): Promise<Element> {
  return new Promise((resolve, reject) => {
    const element = document.querySelector(selector);
    if (element) {
      resolve(element);
      return;
    }

    const observer = new MutationObserver(() => {
      const element = document.querySelector(selector);
      if (element) {
        observer.disconnect();
        clearTimeout(timeoutId);
        resolve(element);
      }
    });

    const timeoutId = setTimeout(() => {
      observer.disconnect();
      reject(new Error(`Element ${selector} not found within ${timeout}ms`));
    }, timeout);

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  });
}

export function findRefreshButton(): HTMLElement | null {
  // より堅牢なセレクター戦略
  const selectors = [
    'button[title*="Refresh"], button[aria-label*="Refresh"]',
    'button .zmdi-refresh',
    '.ant-btn:has(.zmdi-refresh)', // モダンブラウザ用
    '.btn-refresh'
  ];

  for (const selector of selectors) {
    try {
      const element = document.querySelector(selector) as HTMLElement;
      if (element) return element;
    } catch (error) {
      // :has()がサポートされていない場合はスキップ
      continue;
    }
  }

  // フォールバック: テキストベースの検索
  const buttons = document.querySelectorAll('button');
  for (const button of buttons) {
    if (button.textContent?.toLowerCase().includes('refresh') ||
        button.innerHTML.includes('zmdi-refresh')) {
      return button;
    }
  }

  return null;
}
```

### 4. コンテンツスクリプト (src/content/dashboard.ts)
```typescript
import { DOMObserver, waitForElement, findRefreshButton } from '../utils/dom-utils';
import { fetchDashboardData } from '../utils/api';
import { sendMessageToBackground } from '../utils/api';
import { downloadYamlFile, generateFilename } from '../utils/yaml-converter';

class DashboardExporter {
  private exportButton: HTMLButtonElement | null = null;
  private domObserver: DOMObserver;
  private isInitialized: boolean = false;

  constructor() {
    this.domObserver = new DOMObserver();
    this.init();
  }

  private init(): void {
    // DOMが読み込まれるまで待機
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.setupExporter());
    } else {
      this.setupExporter();
    }
  }

  private setupExporter(): void {
    if (this.isInitialized) return;
    
    this.domObserver.addCallback(() => this.injectButton());
    this.domObserver.start();
    this.injectButton();
    this.isInitialized = true;
  }

  private async injectButton(): Promise<void> {
    try {
      // 既にボタンが存在する場合はスキップ
      if (document.getElementById('redash-yaml-export-btn')) {
        return;
      }

      // Refreshボタンを探す
      const refreshButton = findRefreshButton();
      if (!refreshButton) {
        return; // 見つからない場合は何もしない
      }

      // Exportボタンを作成
      this.exportButton = this.createExportButton();
      
      // Refreshボタンの左隣に挿入
      refreshButton.parentNode?.insertBefore(this.exportButton, refreshButton);
      
    } catch (error) {
      console.error('Failed to inject export button:', error);
    }
  }

  private createExportButton(): HTMLButtonElement {
    const button = document.createElement('button');
    button.id = 'redash-yaml-export-btn';
    button.type = 'button';
    button.className = 'ant-btn ant-btn-default';
    button.style.marginRight = '8px';
    
    button.innerHTML = `
      <i class="zmdi zmdi-download m-r-5" aria-hidden="true"></i>
      <span>Export YAML</span>
    `;

    button.addEventListener('click', this.handleExportClick.bind(this));
    
    return button;
  }

  private async handleExportClick(): Promise<void> {
    try {
      // ボタンを無効化（重複実行防止）
      this.setButtonState('loading');

      // 現在のダッシュボードIDを取得
      const dashboardId = this.extractDashboardId();
      
      if (!dashboardId) {
        throw new Error('ダッシュボードIDを取得できませんでした');
      }

      // ダッシュボードデータを直接取得
      const dashboardData = await fetchDashboardData(dashboardId);

      // バックグラウンドスクリプトでYAML変換
      const response = await sendMessageToBackground({
        action: 'exportDashboard',
        dashboardData: dashboardData
      });

      if (response.success) {
        // ファイル名を生成してダウンロード
        const filename = generateFilename(dashboardData.name);
        downloadYamlFile(response.data, filename);
        this.showSuccessMessage();
      } else {
        throw new Error(response.error);
      }

    } catch (error) {
      console.error('Export failed:', error);
      this.showErrorMessage(error instanceof Error ? error.message : '不明なエラーが発生しました');
    } finally {
      this.setButtonState('default');
    }
  }

  private setButtonState(state: 'default' | 'loading'): void {
    if (!this.exportButton) return;

    switch (state) {
      case 'loading':
        this.exportButton.disabled = true;
        this.exportButton.innerHTML = `
          <i class="zmdi zmdi-refresh zmdi-hc-spin m-r-5" aria-hidden="true"></i>
          <span>Exporting...</span>
        `;
        break;
      case 'default':
        this.exportButton.disabled = false;
        this.exportButton.innerHTML = `
          <i class="zmdi zmdi-download m-r-5" aria-hidden="true"></i>
          <span>Export YAML</span>
        `;
        break;
    }
  }

  private extractDashboardId(): string | null {
    // URLからダッシュボードIDを抽出
    const match = window.location.pathname.match(/\/dashboards\/(\d+)/);
    return match ? match[1] : null;
  }

  private showSuccessMessage(): void {
    this.showMessage('YAML export completed successfully!', 'success');
  }

  private showErrorMessage(error: string): void {
    this.showMessage(`Export failed: ${error}`, 'error');
  }

  private showMessage(text: string, type: 'success' | 'error'): void {
    const message = document.createElement('div');
    message.className = `redash-yaml-export-message redash-yaml-export-message--${type}`;
    message.textContent = text;
    
    const styles = {
      success: {
        background: '#f6ffed',
        border: '1px solid #b7eb8f',
        color: '#52c41a'
      },
      error: {
        background: '#fff2f0',
        border: '1px solid #ffccc7',
        color: '#ff4d4f'
      }
    };

    Object.assign(message.style, {
      position: 'fixed',
      top: '20px',
      right: '20px',
      padding: '12px 16px',
      borderRadius: '4px',
      zIndex: '9999',
      fontFamily: 'inherit',
      fontSize: '14px',
      ...styles[type]
    });
    
    document.body.appendChild(message);
    
    setTimeout(() => {
      if (document.body.contains(message)) {
        document.body.removeChild(message);
      }
    }, type === 'error' ? 5000 : 3000);
  }

  public destroy(): void {
    this.domObserver.stop();
    if (this.exportButton?.parentNode) {
      this.exportButton.parentNode.removeChild(this.exportButton);
    }
  }
}

// 初期化
const exporter = new DashboardExporter();

// ページ離脱時のクリーンアップ
window.addEventListener('beforeunload', () => {
  exporter.destroy();
});
```

### 5. API通信処理 (src/utils/api.ts)
```typescript
import { RedashDashboard, ExportMessage, ExportResponse } from './types';

export async function sendMessageToBackground(message: ExportMessage): Promise<ExportResponse> {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Background script response timeout'));
    }, 30000); // 30秒タイムアウト

    chrome.runtime.sendMessage(message, (response: ExportResponse) => {
      clearTimeout(timeout);
      
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
        return;
      }
      
      if (!response) {
        reject(new Error('No response from background script'));
        return;
      }
      
      resolve(response);
    });
  });
}

export async function fetchDashboardData(dashboardId: string): Promise<RedashDashboard> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒タイムアウト

  try {
    const response = await fetch(`/api/dashboards/${dashboardId}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      credentials: 'include',
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      throw new Error(`API request failed: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const data = await response.json();
    
    // データの基本的なバリデーション
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid dashboard data received');
    }

    if (!data.id || !data.name || !Array.isArray(data.widgets)) {
      throw new Error('Dashboard data is missing required fields');
    }

    return data as RedashDashboard;

  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error instanceof Error) {
      if (error.name === 'AbortError') {
        throw new Error('Request timeout: Dashboard data could not be fetched');
      }
      throw error;
    }
    
    throw new Error('Unknown error occurred while fetching dashboard data');
  }
}
```

### 6. YAML変換処理 (src/utils/yaml-converter.ts)
```typescript
import yaml from 'js-yaml';
import { RedashDashboard, YamlOutput, YamlPage } from './types';

export function convertDashboardToYaml(dashboard: RedashDashboard): string {
  try {
    // クエリを含むウィジェットのみを抽出
    const queryWidgets = dashboard.widgets.filter(widget => 
      widget.visualization?.query?.query
    );

    const yamlObj: YamlOutput = {
      _id: generateRandomId(),
      schema_version: '1.3.0',
      icon: null,
      name: dashboard.name,
      palette_key: 'DEFAULT',
      pages: [],
      notebook_param_widgets: []
    };

    queryWidgets.forEach((widget, index) => {
      const query = widget.visualization!.query;
      
      const page: YamlPage = {
        _id: generateRandomId(),
        kind: 'DEFAULT',
        name: query.name || `Query ${index + 1}`,
        body: {
          type: 'doc',
          content: [
            {
              type: 'heading',
              attrs: {
                level: 2,
                hideDefault: false,
                disabledHide: false,
                linkId: generateRandomId()
              },
              content: [
                {
                  type: 'text',
                  text: query.name || `Query ${index + 1}`
                }
              ]
            },
            {
              type: 'sqlBlock',
              attrs: {
                linkId: generateRandomId(),
                sqlId: generateRandomId(),
                connId: generateRandomId(), // 実際の接続IDは動的に設定する必要がある
                args: []
              },
              content: [
                {
                  type: 'sqlBlockName',
                  content: [
                    {
                      type: 'text',
                      text: query.name || `Query ${index + 1}`
                    }
                  ]
                },
                {
                  type: 'sqlBlockBody',
                  content: [
                    {
                      type: 'text',
                      text: query.query
                    }
                  ]
                }
              ]
            }
          ]
        },
        order: index + 1,
        width: {
          fixed_width: 800,
          width_type: 'RANGE',
          max_width: 800
        },
        notebook_param_widget_values: [],
        page_param_widgets: [],
        page_param_widget_values: []
      };

      yamlObj.pages.push(page);
    });

    return yaml.dump(yamlObj, {
      indent: 2,
      noRefs: true,
      sortKeys: false,
      lineWidth: -1,
      noCompatMode: true
    });

  } catch (error) {
    console.error('YAML conversion error:', error);
    throw new Error(`Failed to convert dashboard to YAML: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

function generateRandomId(): string {
  // より堅牢なID生成
  const chars = '0123456789abcdef';
  return Array.from({ length: 24 }, () => 
    chars[Math.floor(Math.random() * chars.length)]
  ).join('');
}

export function downloadYamlFile(yamlContent: string, filename: string): void {
  try {
    const blob = new Blob([yamlContent], { 
      type: 'text/yaml;charset=utf-8' 
    });
    
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    // メモリリークを防ぐ
    setTimeout(() => URL.revokeObjectURL(url), 100);
    
  } catch (error) {
    console.error('File download error:', error);
    throw new Error('Failed to download YAML file');
  }
}

export function generateFilename(dashboardName: string): string {
  const timestamp = new Date().toISOString()
    .replace(/[:.]/g, '-')
    .replace('T', '_')
    .slice(0, 19); // YYYY-MM-DD_HH-MM-SS
    
  const sanitizedName = dashboardName
    .replace(/[^\w\s\-_]/g, '')
    .replace(/\s+/g, '_')
    .toLowerCase()
    .slice(0, 50); // 長すぎるファイル名を防ぐ
    
  return `dashboard_${sanitizedName}_${timestamp}.yml`;
}
```

### 7. バックグラウンドスクリプト (src/background/background.ts)
```typescript
import { convertDashboardToYaml } from '../utils/yaml-converter';
import { ExportMessage, ExportResponse } from '../utils/types';

// メッセージリスナー
chrome.runtime.onMessage.addListener((
  message: ExportMessage, 
  sender: chrome.runtime.MessageSender, 
  sendResponse: (response: ExportResponse) => void
) => {
  if (message.action === 'exportDashboard') {
    handleDashboardExport(message.dashboardData)
      .then(yamlContent => {
        sendResponse({ success: true, data: yamlContent });
      })
      .catch(error => {
        console.error('Dashboard export failed:', error);
        sendResponse({ 
          success: false, 
          error: error instanceof Error ? error.message : 'Unknown error occurred' 
        });
      });
    
    return true; // 非同期レスポンスを示す
  }
});

async function handleDashboardExport(dashboardData: any): Promise<string> {
  try {
    // 入力データの検証
    if (!dashboardData || typeof dashboardData !== 'object') {
      throw new Error('Invalid dashboard data');
    }

    if (!dashboardData.name || !Array.isArray(dashboardData.widgets)) {
      throw new Error('Dashboard data is missing required fields');
    }

    // YAMLに変換
    const yamlContent = convertDashboardToYaml(dashboardData);
    
    if (!yamlContent || yamlContent.trim().length === 0) {
      throw new Error('Failed to generate YAML content');
    }

    return yamlContent;
    
  } catch (error) {
    console.error('Dashboard export error:', error);
    throw error;
  }
}

// Service Worker初期化時の処理
chrome.runtime.onInstalled.addListener((details) => {
  if (details.reason === 'install') {
    console.log('Redash YAML Exporter installed');
  } else if (details.reason === 'update') {
    console.log('Redash YAML Exporter updated');
  }
});
```

### 8. Webpack設定 (webpack.config.js)
```javascript
const path = require('path');

module.exports = {
  entry: {
    'content/dashboard': './src/content/dashboard.ts',
    'background/background': './src/background/background.ts'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
    clean: true
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader',
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: ['.ts', '.js']
  },
  optimization: {
    minimize: false // デバッグを容易にするため
  },
  mode: process.env.NODE_ENV === 'production' ? 'production' : 'development',
  devtool: process.env.NODE_ENV === 'production' ? false : 'source-map'
};
```

### 9. TypeScript設定 (tsconfig.json)
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ES2020",
    "moduleResolution": "node",
    "lib": ["ES2020", "DOM"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "types": ["chrome", "node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### 10. package.json
```json
{
  "name": "redash-yaml-exporter",
  "version": "1.0.0",
  "description": "Chrome extension to export Redash dashboard queries to YAML",
  "main": "dist/background/background.js",
  "scripts": {
    "build": "webpack --mode=production",
    "dev": "webpack --mode=development --watch",
    "lint": "eslint src/**/*.ts",
    "type-check": "tsc --noEmit",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "js-yaml": "^4.1.0"
  },
  "devDependencies": {
    "@types/chrome": "^0.0.258",
    "@types/js-yaml": "^4.0.5",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.50.0",
    "typescript": "^5.0.0",
    "webpack": "^5.88.0",
    "webpack-cli": "^5.1.0",
    "ts-loader": "^9.4.0"
  },
  "keywords": ["chrome-extension", "redash", "yaml", "export"],
  "author": "Your Name",
  "license": "MIT"
}
```

### 11. .gitignore
```
# Dependencies
node_modules/

# Build output
dist/

# TypeScript
*.tsbuildinfo

# Logs
*.log
npm-debug.log*

# Environment variables
.env
.env.local

# OS files
.DS_Store
Thumbs.db

# IDE files
.vscode/
.idea/
*.swp
*.swo

# Chrome extension
*.crx
*.pem
```

### 12. スタイルシート (src/styles/content.css)
```css
#redash-yaml-export-btn {
  transition: all 0.2s ease;
}

#redash-yaml-export-btn:hover {
  background-color: #f5f5f5;
  border-color: #d9d9d9;
}

#redash-yaml-export-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.redash-yaml-export-message {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  max-width: 400px;
  word-wrap: break-word;
}

.redash-yaml-export-message--success {
  background: #f6ffed !important;
  border: 1px solid #b7eb8f !important;
  color: #52c41a !important;
}

.redash-yaml-export-message--error {
  background: #fff2f0 !important;
  border: 1px solid #ffccc7 !important;
  color: #ff4d4f !important;
}
```
